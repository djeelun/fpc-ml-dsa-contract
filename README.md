# fpc-ml-dsa-contract

## Overview
This contract is implemented in C++ and utilizes the Hyperledger Fabric Private Chaincode (FPC) framework, a branch of Hyperledger Fabric (HLF), to enable privacy-preserving smart contracts.

### What is FPC?
FPC leverages Intel Software Guard Extensions (SGX) [1] as a Trusted Execution Environment (TEE) to conceal the processor and application state from network nodes while still permitting transaction verification. This ensures that even peer nodes cannot view potentially sensitive data. More details can be found in the official [Hyperledger Fabric Private Chaincode repository](https://github.com/hyperledger/fabric-private-chaincode).

### Purpose of This Contract
This contract introduces several cryptographic primitives to provide post-quantum resilience in HLF. All cryptographic primitives in this repository rely on lattice-based cryptography to achieve this resilience. The contract supports:
- **Zero-Knowledge Proofs (ZKP)**
- **Digital Signing Algorithm (DSA)**
- **Ciphertext-Dependent Updatable Encryption (c-d UE)**

The contract verifies zero-knowledge Succinct Argument of Knowledge (zk-SNARK) proof messages signed with a DSA. Additionally, it allows users to store and retrieve ciphertexts on the ledger and update them using a key-switching token.

The zk-SNARK protocol employed is **Vesper**, proposed in a thesis by a former Master's student (code available at repository [lfranschman/post-quantum-smart-contract](https://github.com/lfranschman/post-quantum-smart-contract)). The signing algorithm is **Module-Lattice-Based Digital Signing Algorithm (ML-DSA)**, recently standardized by NIST as **FIPS204** [2]. The **c-d UE** scheme follows **Trapdoor Updatable Encryption (TDUE)** as outlined by Huanhuan Chen et al. in CCA-1 Secure Updatable Encryption with Adaptive Security [3].

### Contract Functions
The contract file `ml_dsa_cc.cpp` exposes the following functions:
- `getVerificationResult`
- `putVerificationResult`
- `verifySig`
- `getCipher`
- `putCipher`
- `updateCipher`

#### Functionality
1. **Proof Verification:**
   - `putVerificationResult`: Stores a proof on the ledger (automatically verifies the signature).
   - `getVerificationResult`: Retrieves the verification result for a proof.
   - Enables privacy-preserving proofs (e.g., proving knowledge of a solution to an equation without revealing the solution itself).

These functions allow one to prove something (e.g. a solution to `x^3 + 19x + 5 = 2`, a.k.a. the statement) to the whole network without revealing the contents (i.e. `x`, a.k.a. the witness).
Any users on the network can then verify the proof is valid by requesting the result to a proof (identified by its signature).
Specifically for us, by using SGX we can hide the proof message generated by Vesper.
We may not want the whole network (e.g. a small subset of peer nodes) to be able to inspect this proof message.

2. **Updatable Encryption:**
   - `putCipher`: Stores a ciphertext on the ledger.
   - `getCipher`: Retrieves a stored ciphertext.
   - `updateCipher`: Uses a key-switching token (e.g., a matrix in TDUE) to update the ciphertext to the new epoch.

**Note:** Parameters for TDUE are hardcoded into `tdue.h`. Any change to the parameters (e.g. `n` or `k`) require editing these values and rebuilding the contract. I might change this soon to a more dynamic approach with `malloc`, but decided against it for now.
   
**URGENT TODO:** The `updateCipher` function may handle strings up to around **1.2 million characters** under **128-bit security**. The contract currently throws an exception for strings exceeding **~10,000 characters**, requiring further investigation.

## Setup Instructions
1. **Set Up the FPC Development Environment:**
   - Follow the official [Hyperledger Fabric Private Chaincode setup guide](https://github.com/hyperledger/fabric-private-chaincode).
   - Key requirements:
     - Go language
     - Essential environment variables (`$FPC_PATH`)
     - Docker (for the development environment)
     - GNU Make

2. **(After Setup) Clone This Repository:**
   - Place this repository inside `$FPC_PATH/samples/chaincode/` (recommended, although anywhere in `$FPC_PATH` would technically work).
   - Additional scripts for quick setup can be found in `/qol_scripts` (use at your own discretion).

## Build & Testing
### Build the Contract
Run the following command from the root directory:
```sh
make build
```
This command automatically:
- Downloads external dependencies (e.g., [pq-crystals/dilithium](https://github.com/pq-crystals/dilithium) from GitHub).
- Builds static libraries (as FPC does not support shared libraries due to enclave memory isolation).
- Creates a `_build` directory containing the compiled output (not directly executable).

### Test the Contract
Execute:
```sh
bash test/test.sh
```
This script:
- Sets up a small test network with two peer nodes.
- Uses a Go client (`client_app/ml_dsa.go`) to test contract features.

### Tests Conducted:
- **Signature Verification:**
  - Valid signatures using ML-DSA (44, 87)
  - Corrupt signature/message/public key (test for failure)
- **Signature Storage & Retrieval:**
  - Attempt to retrieve an unavailable signature
  - Store a signature on the ledger and retrieve it
- **Updatable Encryption:**
  - Store ciphertext on the ledger
  - Retrieve ciphertext
  - Update ciphertext and verify the update

Precomputed and manually verified values are stored in:
- `client_app/sig_txts` (for signatures)
- `client_app/tdue_txts` (for ciphertexts)
Files found here are used during the tests.

For setting up a test network and manual transaction querying, refer to the [fpc-ml-dsa-client repository](https://github.com/djeelun/fpc-ml-dsa-client).

## Related Repositories
- [fpc-ml-dsa-client](https://github.com/djeelun/fpc-ml-dsa-client)
- [fpc-ml-web-app](https://github.com/djeelun/fpc-ml-web-app)

## References
1. [Intel SGX](https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html), Intel Software Guard Extensions for Trusted Execution Environments.
2. [FIPS204](https://csrc.nist.gov/pubs/fips/204/final), NIST's post-quantum Module-Lattice-Based Digital Signature Standard.
3. [CCA-1 Secure Updatable Encryption with Adaptive Security](https://eprint.iacr.org/2022/1339) by Huanhuan Chen et al. (2022).

## Contact
For inquiries, contact: [jaylan2993@gmail.com](mailto:jaylan2993@gmail.com)
